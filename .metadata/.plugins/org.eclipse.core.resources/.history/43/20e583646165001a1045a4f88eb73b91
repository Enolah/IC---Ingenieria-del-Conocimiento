package star;
import java.util.*;

public class rejilla {
	private int alto;
	private int ancho;
	private Pair<Integer,Integer> salida;
	private Pair<Integer,Integer> metas ;
	private Pair<Integer,Integer> obstaculos ;
	private Pair<Integer,Integer> puntosDePaso ;
	private dMatriz informacionInterna ;
	private cMatriz representacionInterna;

	private boolean caracteresCorrectos()
	{

		boolean rejillaCorrecta = true;

		for (int fila = 0 ; fila < alto && rejillaCorrecta ; ++fila)
		{

			for (int columna = 0 ; columna < ancho && rejillaCorrecta ; ++columna)
			{

				switch (representacionInterna[fila][columna])
				{
					case '#':
						break;
					case '.':
						break;
					case 'S':
						break;
					case 'M':
						break;
					default:
						rejillaCorrecta = false;
						break;
				}


			}

		}

		return rejillaCorrecta;

	}

	private boolean dimensionCorrecta()
	{

		boolean rejillaCorrecta = true;

		for (int fila = 0 ; fila < alto - 1 && rejillaCorrecta ; ++fila)
		{

			rejillaCorrecta = (representacionInterna[fila].size() == representacionInterna[fila + 1].size());
		}

		return rejillaCorrecta;

	}


	public final void leerDeFichero()
	{

		int fil = 0;
		int col = 0;

		String linea;

		std::ifstream in = new std::ifstream("Tablero.txt");
//C++ TO JAVA CONVERTER TODO TASK: There is no equivalent to implicit typing in Java unless the Java 10 inferred typing option is selected:
		auto cinbuf = std::cin.rdbuf(in.rdbuf());

		do
		{

			linea = new Scanner(System.in).nextLine();

			if (!std::cin)
			{
				std::cin.rdbuf(cinbuf);
				throw std::logic_error("\nERROR AL CARGAR EL FICHERO: NO SE ENCONTRO LA MARCA DE CIERRE DE LA REJILLA.\n");
			}

			if (linea.compareTo("FINAL_DE_REJILLA") != 0)
			{

				cFila f = new cFila();

				col = 0;

				for (char c : linea)
				{

					f.push_back(c);

					c = toupper(c);

					if (c == C_SALIDA)
					{

						salida = new coordenada(fil, col);
					}

					if (c == C_META)
					{

						metas.push_back({fil, col});
					}

					++col;

				}

				++fil;

				this.representacionInterna.push_back(f);

			}

		} while (linea.compareTo("FINAL_DE_REJILLA") != 0);

		alto = fil;

		ancho = col;

		if (!caracteresCorrectos())
		{
			std::cin.rdbuf(cinbuf);
			throw std::logic_error("\nERROR AL CARGAR EL FICHERO: HAY UN CARACTER DISTINTO DE { . , # , M , S } EN LA REJILLA.\n");
		}

		if (!dimensionCorrecta())
		{
			std::cin.rdbuf(cinbuf);
			throw std::logic_error("\nERROR AL CARGAR EL FICHERO: EL NUMERO DE COLUMNAS NO ES IGUAL PARA TODAS LAS FILAS.\n");
		}

		do
		{

			col = Integer.parseInt(ConsoleInput.readToWhiteSpace(true));
			fil = Integer.parseInt(ConsoleInput.readToWhiteSpace(true));

			if (!std::cin)
			{
				std::cin.rdbuf(cinbuf);
				throw std::logic_error("\nERROR AL CARGAR EL FICHERO: NO SE ENCONTRO LA MARCA DE CIERRE DE LOS PUNTOS DE PASO.\n");
			}

			if ((col < 0 || col > ancho) || (fil < 0 || fil > alto) || (col == 0 && fil != 0) || (col != 0 && fil == 0))
			{
				std::cin.rdbuf(cinbuf);
				throw std::logic_error("\nERROR AL CARGAR EL FICHERO: SE INTENTO PONER UN PUNTO DE PASO FUERA DE LA REJILLA.\n");
			}

			if (!(fil == 0 && col == 0) && this.representacionInterna[fil - 1][col - 1] != '.')
			{
				std::cin.rdbuf(cinbuf);
				throw std::logic_error("\nERROR AL CARGAR EL FICHERO: SE INTENTO PONER UN PUNTO DE PASO EN UNA CASILLA YA OCUPADA.\n");
			}

			if (!(fil == 0 && col == 0))
			{

				puntosDePaso.push_back({fil - 1, col - 1});
				representacionInterna[fil - 1][col - 1] = C_PUNTO_DE_PASO;

			}

		} while (!(fil == 0 && col == 0));

		double porcentajeDePenalizacion;
		informacionInterna = dMatriz(alto,dFila(ancho,D_LIBRE));

		do
		{

			col = Integer.parseInt(ConsoleInput.readToWhiteSpace(true));
			fil = Integer.parseInt(ConsoleInput.readToWhiteSpace(true));
			porcentajeDePenalizacion = Double.parseDouble(ConsoleInput.readToWhiteSpace(true));

			if (!std::cin)
			{
				std::cin.rdbuf(cinbuf);
				throw std::logic_error("\nERROR AL CARGAR EL FICHERO: NO SE ENCONTRO LA MARCA DE CIERRE DE LAS PENALIZACIONES.\n");
			}

			if ((col < 0 || col > ancho) || (fil < 0 || fil > alto) || (col == 0 && fil != 0) || (col != 0 && fil == 0))
			{
				std::cin.rdbuf(cinbuf);
				throw std::logic_error("\nERROR AL CARGAR EL FICHERO: SE INTENTO PONER UNA PENALIZACION FUERA DE LA REJILLA.\n");
			}

			if (!(fil == 0 && col == 0) && this.representacionInterna[fil - 1][col - 1] != '.')
			{
				std::cin.rdbuf(cinbuf);
				throw std::logic_error("\nERROR AL CARGAR EL FICHERO: SE INTENTO PONER UNA PENALIZACION EN UNA CASILLA YA OCUPADA.\n");
			}

			if ((porcentajeDePenalizacion < 0 || porcentajeDePenalizacion > 100) || (fil != 0 && col != 0 && porcentajeDePenalizacion == 0))
			{
				std::cin.rdbuf(cinbuf);
				throw std::logic_error("\nERROR AL CARGAR EL FICHERO: SE INTENTO PONER UN PORCENTAJE DE PENALIZACION FUERA DEL RANGO (1-100).\n");
			}

			if (!(fil == 0 && col == 0 && porcentajeDePenalizacion == 0))
			{
}
